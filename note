don't forget to close the connection between server and client after timeout, otherwise after client sends request, it
will keep on waiting. connfd = Accept...  close(connfd)  
and don't forget to release fopen();  fclose(fp);

The reason that your cookie isn't working is because you do in fact need to refresh the page to have it usable, because when you SET it, you can't use it like a variable, only a second refresh will notice its value and use it's functionality. Pain in the ***? YES!
You must set up the page in a way that you are able to SETCOOKIE() and then REFRESH IMMEDIATELY without any consequences.

My code was something along these lines...

setcookie ('CAT_ID','1');	
header ("Location: http://" . $_SERVER['HTTP_HOST'] . dirname($_SERVER['PHP_SELF']) . "SelectYourDrill.php");

Error1:if ($_SERVER["REQUEST_METHOD"] == "POST")
$_SERVER means  currently executing script,so can't use this to check method in another file
Error2:Undefined index with $_POST [registeration[username]]
<input type="text" name="registeration[username]" id="regist_username" placeholder="E-mail">
it's due to $_POST array doesn't find the element with index registeration[username]
--->remove ssymbols[]

	
			//print_r(array_key_exists("loggedin", $_SESSION));
			//foreach ($_SESSION as $value) {
				//echo "$value <br>";
			//}
			_$SESSION['$loggedin'] is WRONG!!!
			it should be _$SESSION['loggedin']

before always only update first row,because of the wrong position of sql,then it always take the
value of 1st time:
//$sql = "UPDATE book SET quantity = '$qc' where id = '$idc'";
				for ($x = 0; $x < $index; $x++) {
					//current value
					$idc = $indice[$x];
					$qc = $quantities[$x];
					$sql = "UPDATE book SET quantity = '$qc' where id = '$idc'";
					//echo "x is " . $x."current id is " .$idc." current quantity is  ".$qc." ";
					if(!$conn->query($sql)) {
						die($idc.mysqli_error($conn));
					}
					echo " index ".$idc. " quantity ".$qc;
					
				}
--->put inside for loop,then it can get update
